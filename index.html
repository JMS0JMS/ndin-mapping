<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Digital Inclusion Hubs – Postcode Mapper (UK)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: flex; flex-direction: row; height: 100vh; }
    .panel {
      width: 360px; padding: 16px; overflow-y: auto;
      border-right: 1px solid #e6e6e6; background: #fafafa;
    }
    h1 { font-size: 16px; margin-bottom: 12px; }
    label { font-size: 12px; color: #444; display: block; margin: 10px 0 4px; }
    input, textarea, button {
      width: 100%; font-size: 14px; padding: 10px;
      border-radius: 10px; border: 1px solid #ccc; box-sizing: border-box;
    }
    textarea { min-height: 160px; }
    button {
      margin-top: 12px; background: #111; color: #fff;
      font-weight: 600; cursor: pointer; touch-action: manipulation;
    }
    #map { flex: 1; }
    .stats { font-size: 13px; margin-top: 12px; }
    .error { color: #b00020; font-size: 12px; white-space: pre-wrap; margin-top: 8px; }

    @media (max-width: 900px) {
      .wrap { flex-direction: column; }
      .panel { width: 100%; border-right: none; border-bottom: 1px solid #e6e6e6; }
      #map { height: 60vh; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h1>Digital Inclusion Hub Mapper</h1>

    <label>Central postcode</label>
    <input id="centre" placeholder="E1 6AN" autocapitalize="characters">

    <label>Centre name (optional)</label>
    <input id="centreName" placeholder="e.g. Birmingham City Centre">

    <label>Hub postcodes (one per line)</label>
    <textarea id="hubs" autocapitalize="characters" placeholder="Format:
SW1A 1AA | Westminster Hub
EC1A 1BB | City Advice Centre"></textarea>

    <label>Radius (km)</label>
    <input id="radius" type="number" value="5" step="0.1" min="0.1">

    <button type="button" onclick="run()">Map hubs</button>

    <div class="stats">
      Inside radius: <span id="inCount">0</span><br>
      Outside radius: <span id="outCount">0</span><br>
      Total mapped: <span id="totalCount">0</span>
    </div>

    <div class="error" id="err"></div>
  </div>

  <div id="map"></div>
</div>

<script>
  // --- Map setup ---
  const map = L.map("map").setView([51.5074, -0.1278], 11);

  // Minimal basemap (CARTO Positron)
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}" + (L.Browser.retina ? "@2x.png" : ".png"),
    {
      subdomains: "abcd",
      maxZoom: 20,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
        '&copy; <a href="https://carto.com/attributions">CARTO</a>'
    }
  ).addTo(map);

  const layerGroup = L.layerGroup().addTo(map);
  let radiusCircle;

  function norm(pc) {
    return (pc || "").trim().toUpperCase().replace(/\s+/g, "");
  }

  // Hub icon (upload gtf-logo.png to the repo alongside index.html)
  const HUB_ICON = L.icon({
    iconUrl: "./gtf-logo.png",
    iconSize: [22, 22],
    iconAnchor: [11, 11],
    popupAnchor: [0, -10]
  });

  // Haversine distance in km
  function distanceKm(aLat, aLon, bLat, bLon) {
    const R = 6371;
    const dLat = (bLat - aLat) * Math.PI / 180;
    const dLon = (bLon - aLon) * Math.PI / 180;
    const lat1 = aLat * Math.PI / 180;
    const lat2 = bLat * Math.PI / 180;
    const h =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(h));
  }

  async function geocodeSingle(pc) {
    const r = await fetch("https://api.postcodes.io/postcodes/" + encodeURIComponent(pc));
    const j = await r.json();
    if (!j.result) throw new Error("Invalid centre postcode");
    return j.result;
  }

  async function geocodeBulk(list) {
    const r = await fetch("https://api.postcodes.io/postcodes", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ postcodes: list })
    });
    const j = await r.json();
    if (!j.result) throw new Error("Bulk lookup failed");
    // NOTE: This filters failed results out. If you want perfect name↔postcode pairing even with failures,
    // we can adjust this to keep ordering and show failures in the UI.
    return j.result.filter(x => x.result).map(x => x.result);
  }

  async function run() {
    document.getElementById("err").textContent = "";
    layerGroup.clearLayers();
    if (radiusCircle) map.removeLayer(radiusCircle);

    try {
      const centrePc = norm(document.getElementById("centre").value);
      const centreName = document.getElementById("centreName")?.value?.trim() || "Centre";

      const hubLines = document.getElementById("hubs").value
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(Boolean);

      const hubs = hubLines.map(line => {
        const parts = line.split("|").map(p => p.trim());
        const postcode = norm(parts[0] || "");
        const name = parts[1] || postcode;
        return { postcode, name };
      }).filter(h => h.postcode);

      const radiusKm = Number(document.getElementById("radius").value);

      if (!centrePc || !hubs.length) throw new Error("Enter centre + at least one hub postcode.");
      if (!Number.isFinite(radiusKm) || radiusKm <= 0) throw new Error("Radius must be a positive number (km).");

      const centre = await geocodeSingle(centrePc);
      const hubResults = await geocodeBulk(hubs.map(h => h.postcode));

      const cLatLng = [centre.latitude, centre.longitude];

      L.marker(cLatLng)
        .addTo(layerGroup)
        .bindPopup(`<strong>${centreName}</strong>`)
        .bindTooltip(centreName, {
          permanent: false, // set true if you want it always visible
          direction: "top",
          offset: [0, -8]
        })
        .openPopup();

      // Ring only (no fill)
      radiusCircle = L.circle(cLatLng, {
        radius: radiusKm * 1000,
        fill: false,
        weight: 2
      }).addTo(map);

      let inside = 0, outside = 0;
      const bounds = [cLatLng];

      hubResults.forEach((h, i) => {
        const hubMeta = hubs[i]; // assumes bulk response preserves order for successful items
        const d = distanceKm(centre.latitude, centre.longitude, h.latitude, h.longitude);
        const ll = [h.latitude, h.longitude];
        bounds.push(ll);

        if (d <= radiusKm) inside++; else outside++;

        const marker = L.marker(ll, { icon: HUB_ICON }).addTo(layerGroup);

        marker.bindTooltip(hubMeta?.name || hubMeta?.postcode || "Hub", {
          direction: "top",
          offset: [0, -6],
          opacity: 0.95,
          sticky: true
        });

        marker.bindPopup(
          `<strong>${hubMeta?.name || "Hub"}</strong><br>${hubMeta?.postcode || ""}<br>${d.toFixed(2)} km`
        );
      });

      map.fitBounds(bounds, { padding: [30, 30] });

      document.getElementById("inCount").textContent = inside;
      document.getElementById("outCount").textContent = outside;
      document.getElementById("totalCount").textContent = hubResults.length;

    } catch (e) {
      document.getElementById("err").textContent = e.message || String(e);
    }
  }
</script>
</body>
</html>
